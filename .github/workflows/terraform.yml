name: Terraform QA Prod CI CD

on:
  workflow_call:
    secrets:
      env:
        description: Input vraibles required by terrafrom
        required: true

# Allow only one of this workflow to run at a time per branch.
concurrency:
  # resolves to the name of the GitHub Actions workflow AND conditional expression to either use the PR branch name that triggered the workflow (head_ref) or, if thereâ€™s no branch name available, it uses a unique run ID (run_id).
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true #cancels any previous runs in the same concurrency group when a new run is triggered.

#read repository contents, write deployments and pull requests
permissions:
  contents: read
  pull-requests: write

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  labels:
    runs-on: ubuntu-latest

    # defines an output for the workflow job (assigns the output of a previous step to the matrix output)
    outputs:
      matrix: ${{ steps.labels.outputs.result }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

        # List changed environment directories when PR is opened or updated by bots
      - name: Get changed environments
        if: contains(github.event.action, 'opened') || contains(github.actor, '[bot]')
        id: changed
        uses: tj-actions/changed-files@v35
        with:
          dir_names_max_depth: 2
          dir_names: true
          files: environments/** infrastructure/**
          json_raw_format: true
          json: true

      # Checks if there are modified files in the specified directories.
      # Extracts environment labels from the file paths and prefixes them with tf:.
      # Adds these labels to the PR, which can help in categorizing or triggering further actions based on the environments affected.
      - name: Add changed environment labels once
        if: steps.changed.outcome == 'success' && toJSON(fromJSON(steps.changed.outputs.all_modified_files)) != '[]'
        uses: actions/github-script@v6
        env:
          changed: ${{ steps.changed.outputs.all_modified_files }}
        with:
          # uses JavaScript to interact with the GitHub API.
          # str.substring(str.indexOf('/') + 1) removes the initial directory (assuming str starts with something like environment/prod/...) and takes the rest as the environment name. So a change in environment/prod would yield a label like tf:prod.
          script: |
            // Parse changed environment directory paths then add labels
            // in the format: ['tf:label1', 'tf:label2']
            const labels = JSON.parse(process.env.changed).map((str) => {
              return 'tf:' + str.substring(str.indexOf('/') + 
              1);
            });
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              labels: labels,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

      # Output a list of 'tf' prefixed labels (retrieves labels associated with the most recent pull request (PR) for a specific commit and filters out those starting with the prefix tf.)
      - name: Get labels
        uses: actions/github-script@v6
        id: labels
        with:
          script: |
            return (
            await github.rest.repos.listPullRequestsAssociatedWithCommit({
                // Short-circuit evaluation to get a SHA from any change event
                commit_sha: context.payload.after || context.payload.pull_request.head.sha || context.sha,
                owner: context.repo.owner,
                repo: context.repo.repo,
            })
            ).data[0].labels
            .filter((label) => label.name.startsWith('tf'))
            .map((label) => {
                let [head, body] = label.name.split(':');
                return [head, body];
            });

  run:
    needs: [labels]
    if: toJSON(fromJSON(needs.labels.outputs.matrix)) != '[]'
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        path: ${{ fromJSON(needs.labels.outputs.matrix) }}

    environment: ${{ matrix.path[1] }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Environment variables
        run: |
          string='${{ matrix.path[1] }}'
          if [[ $string == *'--'* ]]; then
            echo tf_environment=${string/--*/} >> $GITHUB_ENV
            echo tf_workspace=${string/*--/} >> $GITHUB_ENV
          else
            echo tf_environment=${string} >> $GITHUB_ENV
            echo tf_workspace='default' >> $GITHUB_ENV
          fi
          for i in '${{ secrets.env }}'; do printf '%s\n' $i >> $GITHUB_ENV; done

        # Terraform workspace setup
      - name: Terraform workspace
        if: env.tf_workspace != 'default'
        uses: dflook/terraform-new-workspace@v1
        with:
          workspace: ${{ env.tf_workspace }}
          path: environments/${{ env.tf_environment }}
          backend_config_file: environments/backend.tfvars
          backend_config: key=environments/${{ env.tf_environment }}/terraform.tfstate

        # Initialize Terraform for General Infrastructure
      - name: Terraform Init (General Infrastructure)
        if: env.tf_environment == 'infrastructure'
        run: terraform init -backend-config="path=infrastructure/terraform.tfstate" -chdir=infrastructure

        # Plan Changes for General Infrastructure
      - name: Terraform plan (General Infrastructure)
        if: env.tf_environment == 'infrastructure' && github.event_name == 'pull_request'
        uses: dflook/terraform-plan@v1
        with:
          label: "infrastructure"
          path: infrastructure
          backend_config_file: infrastructure/backend.tfvars

        #  Apply Changes for General Infrastructure
      - name: Terraform apply (General Infrastructure)
        if: env.tf_environment == 'infrastructure' && (github.event_name == 'push' || contains(matrix.path[0], 'auto_approve'))
        uses: dflook/terraform-apply@v1
        with:
          label: "infrastructure"
          path: infrastructure
          backend_config_file: infrastructure/backend.tfvars

        # Environment-specific Terraform steps
      - name: Terraform Init (Environment-Specific)
        if: env.tf_environment != 'infrastructure'
        run: terraform init -backend-config="path=environments/${{ env.tf_environment }}/terraform.tfstate" -chdir=environments/${{ env.tf_environment }}
  
      - name: Terraform plan (Environment-Specific)
        if: env.tf_environment != 'infrastructure' && github.event_name == 'pull_request'
        uses: dflook/terraform-plan@v1
        with:
          label: ${{ matrix.path[1] }}
          destroy: ${{ contains(matrix.path[0], 'destroy') }}
          workspace: ${{ env.tf_workspace }}
          path: environments/${{ env.tf_environment }}
          backend_config_file: environments/backend.tfvars
  
      - name: Terraform apply (Environment-Specific)
        if: env.tf_environment != 'infrastructure' && (github.event_name == 'push' || contains(matrix.path[0], 'auto_approve'))
        uses: dflook/terraform-apply@v1
        with:
          label: ${{ matrix.path[1] }}
          destroy: ${{ contains(matrix.path[0], 'destroy') }}
          workspace: ${{ env.tf_workspace }}
          path: environments/${{ env.tf_environment }}
          backend_config_file: environments/backend.tfvars